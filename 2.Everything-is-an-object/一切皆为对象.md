# 一切皆为对象

> “如果我们使用另外一种语言交流，就会发现一个不同的世界”。-Ludwig Writtgenstein(1889-1951)

混合语言允许多种语言风格，C++是C语言的一种超集，其中包含了一些C语言不具备的特性，但是C++向后兼容C语言必须保持混合性，这使得C++的某些方面过于复杂。尽管C++和Java都是混合语言，但是Java的设计者认为这种混合性并不像在C++中那么重要，Java是一种基于C++的纯面向对象语言。

## 使用引用操纵对象

每一门编程语言都有自己操纵内存中元素的方式。开发者必须要注意操纵的对象是什么类型，是直接操纵元素本身，还是使用某种间接的形式操纵元素(如C和C++中的指针)？**在Java中将所有的事物都看作对象，并使用*引用(refrence)*来操纵对象**。可以将对象和引用想象成电视和遥控器，遥控器和电视之间存在某种联系，当人们想要操纵电视机如“换频道”，“降低音量”等，人们操作的只是遥控器，遥控器本身来控制电视机的改变。并且如果想要到其他房间能够继续遥控电视机，只需要携带遥控器即可(不需要搬上电视机)。

类似的，遥控器也能够单独存在，并不一定需要一个电视机。也即是说，引用不一定必须要有一个对象与之关联，这样我们就可以提前声明一个引用而无需初始化：

```java
String s;
```

如果一个引用没有对应的对象，当向引用发送消息时会产生错误，因为引用没有一个具体的对象来接受这条消息。因此为了安全起见，在声明引用时就对其初始化：

```java
String s = "abcd";
```

在该处使用到了Java的一个特定：String类型可以使用文本字符串初始化。一般其他的对象都必须使用new关键字初始化。

## 对象创建

根据以上知识了解到，为了安全起见，创建引用时就需要初始化一个对象。在Java中，一般使用**new**关键字来创建一个新的对象，比如说创建一个字符串：

```java
String s = new String("abcd");
```

###  对象存储位置

了解Java在程序运行时对象的存储方式以及内存分配是很有用的，大概有5个存储数据的地方：

1. **寄存器(Register)**。这是一种最快速的存储方式，因为与其他存储器存在的位置不同，它存在于处理器中。但是寄存器的数量非常有限，因此寄存器是按需分配的。开发者不同直接控制，也不能在程序中感受到任何寄存器存在的迹象(在C和C++中允许开发者向编译器建议寄存器的分配方式)。
2. **栈空间(Stack)**。存在于通用随机访问存储器(Random-Access memory，RAM)中，可以通过*堆栈指针(stack pointer)*来获取处理器的直接支持。堆栈指针向下移动分配新的内存，向上移动则释放内存。这是一种仅次于寄存器的快速有效的分配存储方式。创建程序时，Java系统必须知道存储于堆栈区上的所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，因此即便某些Java数据(特别是对象引用)存储在栈上，Java的具体对象并没有存储到其上。
3. **堆空间(Heap)**。存放Java对象的通用内存池(也位于RAM区域)。与栈空间不同的是，编译器不需要知道堆空间中存储数据的生命周期，因此堆空间的存储分配具有很大的灵活性。当需要新的对象时，只需要使用**new**关键字创建一个对象，在代码执行时堆空间就会自动给该对象分配存储。当然为了这种灵活性也付出了一定的代价：分配和回收堆空间存储比栈空间花费更长的时间。
4. **常量存储(Constant storage)**。常量值通常会直接放到程序代码中，这是一种安全的方式因为其值不会再被改变。有时在嵌入式系统中，常量会和其他部分隔离，这样就可以将其放到只读存储器(Read-Only memory，ROM)中。
5. **非RAM存储(Non-RAM storage)**。如果数据能够在程序外存活，也就是说可以不受程序控制，在程序没有运行时也存在，这种数据就可以存储在非RAM存储中。其中两个基本的例子是*流对象(streamed objects)*和*持久化对象(persistent objects)*，流对象能够转化成字节流发送给其他机器，持久化对象能够存储到磁盘中，因此即使程序终止，它们仍然可以保持自身的状态。这种存储的技巧在于：将对象转化为可以存放到其他媒介上的事物，当需要时，仍然可以转化为常规RAM对象状态。Java提供了*轻量级持久化(lightweight persistence)*的支持，如JDBC和Hibernate之类的机制提供了更加复杂的在数据库中存储和读取对象信息支持。

### 基本类型(primitive types)

在Java中有一类特殊的的数据类型-基本类型，这一种类型采用了C和C++相同的方法来初始化，一般不使用**new**关键字来创建对象，而是直接创建非引用的自动变量，该变量直接保存值，置于栈中，比new创建的对象更加高效。Java确定了每种基本类型的大小，不会像其他大多数语言一样随着机器架构的变化而变化。这种所占空间大小不变性是Java编写的程序比其他语言更具有移植性的原因之一。 

| 基本类型 |  大小  |                            最小值                            |                            最大值                            | 包装器类型 |
| :------: | :----: | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------: |
| boolean  |   -    |                              -                               |                              -                               |  Boolean   |
|   char   | 16bits |                          Unicode 0                           | Unicode ![$2^{16}-1$](http://latex.codecogs.com/gif.latex?%5Cinline%20%5Clarge%20%242%5E%7B16%7D-1%24) | Character  |
|   byte   | 8bits  |                             -128                             |                             +127                             |    Byte    |
|  short   | 16bits | ![$-2^{15}$](http://latex.codecogs.com/gif.latex?%5Cinline%20%5Clarge%20%24-2%5E%7B15%7D%24) | ![$+2^{15}-1$](http://latex.codecogs.com/gif.latex?%5Cinline%20%5Clarge%20%24&plus;2%5E%7B15%7D-1%24) |   Short    |
|   int    | 32bits | ![$-2^{31}$](http://latex.codecogs.com/gif.latex?%5Cinline%20%5Clarge%20%24-2%5E%7B31%7D%24) | ![$+2^{31}-1$](http://latex.codecogs.com/gif.latex?%5Cinline%20%5Clarge%20&plus;2%5E%7B31%7D-1) |  Integer   |
|   long   | 64bits | ![$-2^{63}$](http://latex.codecogs.com/gif.latex?%5Cinline%20%5Clarge%20%24-2%5E%7B63%7D%24) | ![$+2^{63}-1$](http://latex.codecogs.com/gif.latex?%5Cinline%20%5Clarge%20%24&plus;2%5E%7B63%7D-1%24) |    Long    |
|  float   | 32bits |                           IEEE754                            |                           IEEE754                            |   Float    |
|  double  | 64bits |                           IEEE754                            |                           IEEE754                            |   Double   |
|   void   |   -    |                              -                               |                              -                               |    Void    |

所有的数值类型都有正负号。boolean类型的大小并没有明确定义，只定义了**true**和**false**两个值。基本类型具有的包装器类，允许在堆中创建一个非基本对象用来表示对应的基本类型。如：

```java
//(1)可以使用new创建包装类型
char c = 'x';
Character ch = new Character(c);
//(2)也可以直接指定对应的值
Character ch = new Character('x');
//(3)Java SE5开始可以自动将基本类型转化为包装类型
Character ch = 'x';
char c = ch;
```

> 注意：**包装器类型在使用自动包装特性直接用基本数据类型赋值时(即不使用new关键字创建包装器类型)，包装器类型必须与基本类型相对应，不然会报编译器错误**。其中基本类型中long和float的表现形式与其他类型有所区别，long类型数据必须在其后加上L后缀(不加默认表示int类型)，float类型必须在其后加上f后缀(默认不加表示double类型)。
>
> ```java
> Boolean b = false;
> Byte bt = 1;
> Short st = 2;
> Integer ir = 12;
> //Long lg = 1000;是一种错误的赋值方式，会报编译时异常
> Long lg = 1000L;
> //Float ft = 0.2;也是一种错误的赋值方式，会报编译时异常
> Float ft = 0.2f;
> Double de = 1.22223;
> Character character = 'c';
> ```

> 注：在上面的表格中，有使用一些数学公式，在github上本身是不支持LaTex语法的，在Google浏览器中可以安装插件[MathJax Plugin for Github](https://link.zhihu.com/?target=https%3A//chrome.google.com/webstore/detail/github-with-mathjax/ioemnmodlmafdkllaclgeombjnmnbima)，但是插件安装后只能自己查看，其他人也必须安装插件才能查看数学公式。为了方便其他人查看，此处我采用[CodeCogs Equation Editor](http://latex.codecogs.com/)在线将数学公式转换为图片，并将图片插入文档中。

#### 高精度数字

Java提供了2个可以执行高精度计算的类：**BigInteger**和**BigDecimal**。虽然它们大体都属于包装类，但它们并不存在对应的基本类型。

- 这两个类提供的操作与基本类型所能执行的操作大体相似。也就是说，能够使用**BigInteger**和**BigDecimal**做任何**int**和**float**能做的操作，只不过必须使用方法调用替代运算符。这样做复杂了很多，因此运算速度相对较慢，但是提高了运算精度。
- **BigInteger**支持任意精度的整数，也就是说在运算中可以准确的表示任意大小的整数值，并且不会丢失任何信息。类似的，BigDecimal支持任何精度的定点数，可以用于进行精确的货币计算。                                                                                                                              

### Java数组

几乎所有的编程语言都支持数组。在C和C++中使用数据是很危险的，因为这些数组就是内存块，如果程序访问自身内存块之外的数组或者在数组初始化之前使用，会发生难以预料的结果。Java数组会保证被初始化，并且无法访问数组范围外的数据。Java在每个数组中都会花销少量内存并在运行时验证index下标，以此来进行范围检测，提高了Java的安全性和效率。

当创建数组对象时，实际上就是创建了一个引用数组，并且每个引用都会被自动初始化为**null**。引用为null就表示该引用还没有指向某个对象。在使用引用之前，必须为其指定一个对象，一旦使用为**null**的引用，在运行时就会报错。

## 清理对象

在其他大多数的语言中，变量的生命周期占据着很重要第部分，变量周期混乱往往会产生大量bug。但在Java中，虚拟机会自动帮我们完成相应的清理工作，极大的简化了开发者的工作量。

### 作用域

大多数的过程型语言都有*作用域(scope)*的概念，作用域决定了在其内定义的变量的可见性和生命周期。在C，C++和Java中，作用域都是由花括号{}的位置决定的。在作用域内的变量只在域结束之前可用。

```java
{
    int x = 12;
    //只有x可用
    {
        int q = 96;
        //x和q均可用
    }
    //只有x可用，q已经不在作用域范围
}
```

要善于运用缩进使得Java代码更易于阅读，Java是一种自由风格的语言，空格、制表符和换行符都不会影响运行结果。

与C和C++不同的是，在作用域范围内变量不能重复声明定义，这样编译器会报异常。Java设计者觉得这样会使得程序混乱，如：

```java
{
    int x = 12;
    {
        int x = 96;//不合法
    }
}
```

### 对象作用域

Java对象的生命周期与基本类型不同，当使用**new**关键字创建一个Java对象，在作用域结束后对象仍然存在。如：

```java
{
	String s = new String("A String");
}//作用域结束
```

s引用在作用域结束后就消失了，但是s指向的String对象还一直存在于内存中。但是在作用域结束后，我们也无法继续使用s来操纵该对象，但是可以传递和复制对象引用，这样就能在该作用域结束后继续使用该对象。在C++中，必须确保对象的保留时间和需要对象的时间一致，并且在使用完之后必须将其销毁；但是在Java中，**new**关键字创建的对象在需要时可以一直保留下去，不需要用户手动销毁。

这样带来了一个问题，Java对象不需要开发人员手动销毁，那又是靠什么来回收不需要的对象，防止资源浪费的呢？其实Java中有一个“*垃圾回收器(garbage collector)*”，它会自动查看**new**出来的对象并根据对象是否存在引用判断哪些对象不会再被使用，随后释放这些无引用的对象资源，以便提供给其他对象使用。这样开发者在需要时使用**new**关键字创建对象，虚拟机会自动清理掉不再使用的对象，这样就解决了因为开发者忘记释放内存而导致的内存泄漏问题。

## 创建新的数据类型：类

如果万物都可看作对象，那么是什么决定了，对象的外观和行为呢？换句话说，是什么确定了对象的类型？按理说可能会有一个“type”的关键字确定对象的含义；但是，从历史上讲，大多数的面向对象语言将**class**来表示新的数据类型，**class**关键字之后一般跟着类型名。如：

```java
class ATypeName {
    /*Class Body*/
}
//以上就声明了一种新的类型，ATypeName，可以使用new关键字创建相应对象
ATypeName a = new ATypeName();
```

#### 属性和方法

在定义类时，可以在类中定义两种类型的元素：*属性(fields，数据成员)*和*方法(function，成员方法)*。属性可以是任何类型的对象引用或者基本数据类型，如果是一个对象引用，可以与相应的对象实体进行通信，并且在操纵对象之前必须对引用进行初始化。

每个对象都有自己的属性存储空间，不会与其他对象共享。可以使用**引用.属性名**的方式来访问或修改其属性值，如果想要访问或修改属性对象中的属性值，类似的可以使用**引用.属性对象名.属性值**来访问修改。如下所示：

```java
//变速器
class GearBox{
	//档位
    int gearPosition;  
}

//汽车
class Car {
	//速度
    int speed;
    GearBox gearBox;
}

//创建car对象
Car car = new Car();
//修改汽车速度值
car.speed=3;
//修改汽车变速器档位，
//注意：在使用gearBox之前必须对其进行初始化
car.gearBox.gearPosition=1;
```

##### 基本对象成员默认值

与类对象成员不同，基本对象成员即便不初始化也能保证其具有默认值。基本类型对象只有在是类成员时Java才会保证对其进行初始化，以确保基本类型成员都具有默认值，减少程序bug。但是这些默认值对于程序而言不一定就是正确的，因此所有类成员最好都进行明确初始化。这些保证并不适用于*局部变量(local variables，非成员属性)*，比如说在某个方法中定义的变量：`int x;`，x在使用之前未初始化得到的可能时任意值，不会被自动初始化为0。在Java中使用未初始化的变量会得到编译时错误告知变量应该被初始化，这也是Java优于C++的地方之一(许多C++编译器会警告未初始化变量，但在Java中是错误)。下表描述了基本成员变量的一些默认值：

| 基本类型 |     默认值     |
| :------: | :------------: |
| boolean  |     false      |
|   char   | '\u0000'(null) |
|   byte   |    (byte)0     |
|  short   |    (short)0    |
|   int    |       0        |
|   long   |       0L       |
|  float   |      0.0f      |
|  double  |      0.0d      |

## 方法、参数和返回值

在很多语言中使用*function(函数)*来描述命名子程序，但在Java中常使用*method(方法)*这个术语来描述。Java中方法决定了对象能够接受什么样的消息。方法的基本组成部分包括：方法名、参数、返回值和方法体。如下结构所示：

```java
/**
* ReturnType代表返回值，表示调用方法返回的值类型
* methodName表示方法名
* arguments表示参数列表，描述了调用该方法时需要传递的参数类型和名字信息。方法名和参数列表一起构成了唯一标识
* 某个方法的“方法签名”。
*/
ReturnType methodName(arguments) {
  /*方法体*/
}
```

Java中的方法只能作为类中的一部分创建，方法只能通过对象调用且该对象必须能够执行该方法调用。如果调用了某个对象的错误(不存在)的方法将会得到一个编译时错误。通过"*对象.方法名(参数列表)*"的方式调用对象中的方法，即`objectName.methodName(arg1,arg2,arg3);`。这种调用方法的行为在面向对象语言中通常描述为"*向某个对象发送消息*"。

```java
/**
* 调用a对象中的f方法，并且f方法返回int类型值
*/
int x = a.f();
```

#### 参数列表

参数列表指定了传递给方法的参数信息，这些信息采用对象的形式传递，因此在参数列表中必须指定每个参数的对象类型以及参数名。调用方法时，传递的参数类型必须正确，否则会报编译时异常。

```java
/**
* 该方法用于计算指定String字符串需要多少byte才能保存相关信息(在Unicode字符中，String类型中的每个char字符* 占16bits或者2bytes)。在该方法中需要传递String类型的参数，参数名为s，方法调用传递的是对象的引用。
*/
int storage(String s) {
  return s.length() * 2;
}
```

在Java中，**return**关键字做了2件事情：告诉编译器该方法已经执行完毕，可以结束；return关键字之后的值为方法结束后的返回值。可以通过return来返回任何类型的值，但如果不想有任何返回值，可以指定方法的返回类型为**void**。当返回类型为void时，return关键字只是表示结束该方法，并且在到达方法结束位置时并不一定需要return关键字。在方法的任何地方都可以返回，但是在非void返回值类型时，编译器强制要求一个返回值。

```java
boolean flag() {
  return true;
}

double naturalLogBase() {
  return 2.718;
}

void nothing() {
  return;
}

/**
* 返回值为void类型不需要return
*/
void nothing2() {}
```

## 构建Java程序

### 名称可见性

在任何语言中都会有名称控制的问题，在程序某个模块中定义了一个方法名称，另一个程序员在程序的另一个模块也定义了一个相同名称的方法，这样该怎么区分这两个方法呢？在C中这是一个很严重的问题，因为程序中往往包含有很多难以管理相互冲突的名称，在C++中将方法嵌入类中从而避免了与其他类中的方法名冲突。但是C++仍然允许全局数据和全局方法，因此名称冲突的问题依然存在。为了解决这个问题，C++使用其他关键字引入了*名称空间(namespaces)*的概念。

Java采取了另外一种完全不同的方法来解决这个问题，为了给类库生成一个完全不会与其他名称混淆的名字，Java设计者推荐程序员采用自身域名倒序的方法来命名包名，这样就能够保证生成的名称是独一无二的。比如说公司域名为*MindView.net*，关于foidles的utility类库包名就可以命名为*net.mindview.utility.foibles*，其中`.`用于分割子目录。这种机制意味着所有的文件都自动存活在自身的命名空间中，并且文件中的每个类都具有唯一标识符，从而防止命名冲突。

### 引用其他组件

在程序中调用其他组件时，编译器必须知道怎么定位这个组件。如果调用者与被调用组件在同一个文件中，可以直接调用该组件。但是如果被调用组件在其他文件中，这种情况又该怎么办呢？你可能觉得编译器足够智能到可以自己找到使用的组件，这样就不需要我们再做其他事情。但是这种情况存在一个问题，如果在程序或者类库中存在多个相同名称的组件，这个时候编译器就无法确定你到底使用的是哪一个组件。因此，为了解决这个问题，你必须显示声明想要使用的组件。在Java中可以使用**import**关键字来准确告诉编译器你想引用的组件。

```java
//告诉编译器你想使用java.util.ArrayList类
import java.util.ArrayList;
//如果想要使用java.util包中多个类，只需要使用通配符引用即可，不需要每个类都引用一遍
import java.util.*;
```

### static关键字

通常来讲，当创建类时就是在描述那个类的对象的行为和外观。只有使用**new**关键字才能获取一个对象，也就是会所只有**new**关键字创建对象后才会分配数据存储空间并且方法才对外可用。那么使用这种有2种情况是无法解决的：

- 无论创建多少对象，甚至没有创建任何对象，只想给特定属性分配单一存储空间。
- 希望某个方法不与具体对象进行绑定，也就是说，即便没有创建对象也能够调用该方法。

在Java中可以使用**static**关键字来实现以上2个需求，**staitc**意味着声明的属性或者方法不与任何具体实例对象进行绑定，即便没有创建实例对象也能够调用static方法和或者访问static属性。非static方法和属性，必须在对象初始化之后使用对象引用进行调用或访问，从另一个方面来讲，static方法也不能直接调用访问非static方法和属性，必须通过对象引用来进行。**通常我们调用static方法或者属性通过"*类.方法名*"或者"*类.属性名*"的形式调用，而不是"*对象.方法名*"或"*对象.属性名*"，这样既强调了方法或者属性的static结构，还在某些情况下为编译器提供了更好的优化机会。**

一些面向对象语言使用*类数据(class data)*和*类方法(class method)*两个术语，来表示某些数据和方法作为整个类而不是某个对象而存在。

```java
/**
* 想要将某个方法或属性static化，只需要将关键字放到声明处即可
*/
class StaticTest {
  static int i = 47;

  static void increment() {
    StaticTest.i++;
  }
}

/**
* 因为StaticTest类中的i为static，无论StaticTest有多少实例，i都只有1片存储，因此st1.i和st2.i应该是相同
* 的，都是47
* 因为static方法或属性是公共的，不属于某一个具体的对象，通常使用类.方法名或者类.属性名来调用static方法或属 * 性，即在此处使用StaticTest.increment()和StaticTest.i
* output:47,47,48,49,50
*/
public class Test{
  public static void main(String[] args) {
    StaticTest st1 = new StaticTest();
    StaticTest st2 = new StaticTest();
    System.out.print(st1.i+",");
    System.out.print(st2.i+",");
    st1.increment();
    System.out.print(st1.i+",")
    st2.increment();
    System.out.print(st2.i+",");
    StaticTest.increment();
    System.out.print(StaticTest.i+",");
  }
}
```

## 第一个Java程序

```java
//HelloDate.java
/**
* 此处引入java.util.*包，因为程序中需要使用java.util.Date类。当然如果只需要使用到java.util.Date，也可 * 以直接导入import java.util.Date
*/
import java.util.*;

public class HelloDate {
  public static void main(String[] args) {
    //System.out.print方法为System.out类中的静态方法，表示标准输出
    System.out.print("Hello,it's ");
    System.out.println(new Date());
    //在运行程序时System.getProperties()获取到所有的系统属性，其list()能够将获取结果发送给相应参数
    System.getProperties().list(System.out);
    //使用System.getProperty()获取指定的属性内容
    System.out.println(System.getProperty("user.name"));
    System.out.println(System.getProperty("java.library.path"));
  }
}
```

- 在类文件的开始，必须使用**import**关键字引入代码中使用到的其他类。但是**java.lang**包会被默认导入到每个Java文件中，因此不需要显示引入。
- 如果想要创建一个能够独立运行的程序，文件中必须存在某个类与文件名相同，并且其中必须包含*main()*方法`public static void main(String[] args){}`。main方法为一个程序的入口，其中public表示该方法对外界可用，static表示该方法为静态方法，String[]为方法需要接受的参数类型，args为参数名，一般该参数通过命令行传入。

### 编译运行

在编译运行程序之前，需要有一个Java运行环境，可以从[Java SE官方网站](https://www.oracle.com/technetwork/cn/java/javase/downloads/index.html)下载jdk安装，在安装完成之后先配置好环境变量以便系统能够找到**javac**和**java**命令，然后就可以编译运行java程序了。

- javac命令执行编译，每个class都会生成一个.class中间文件。**javac HelloDate.java**命令编译程序，会生成一个叫**HelloDate.class**的编译文件。
- java命令运行程序，其实它执行的是.class文件，且只有源文件中有main方法入口的class，才能使用java命令指令，否则会报错。**java HelloDate**命令运行java程序，会输出上面程序中的内容。

## 注释和嵌入式文档

在Java中有2种注释风格，一种是传统C风格注释`/*注释内容*/`，在`/*`和`*/`中的内容都会被编译器忽略，可以进行跨行注释；另一种源自C++`//`，这种风格的注释从注释符开始一直到该行结束，不能跨行。

```java
//==============第一种注释风格==============
/*
* 这是注释内容。
* 请在修改内容后也修改相应的注释内容，
* 以便后来开发人员理解
*/

/*上面的注释内容与这种是相同效果，同一种注释类型*/

//==============第二种注释风格==============
//这是注释内容。请在修改内容后也修改相应的注释内容，以便后来开发人员理解
```

### 注释文档

编写代码文档最大的问题就是文档的维护，如果代码与文档分离，每次代码修改都需要手动去修改相应的文档，这是一项很大且乏味的工程量。解决办法就是：将文档和代码联系在一起，最简单的的方式就是将所有的内容都放到同一个文件中，使用特殊的注解语法标记文档内容，并在相应内容修改后使用工具提取这些注释将其转换为正确有用的格式。在Java中这种导出工具叫做*javadoc*，是JDK安装的一部分内容。它使用了Java 编译器的某些技术来查找程序中的特定注释标签，将类名和方法名提取出来，一起生成很好的程序文档。

Javadoc的输出是一个能够在Web浏览器中查看的HTML文档，通过javadoc我们只需要创建和维护单一的源文件，就能自动生成有用的文档。此外，如果开发者想要对Javadoc处理过的信息执行特殊操作，可以通过编写自己的一种被称为**doclets**的Javadoc处理器来实现。

### 语法

所有的Javadoc命令都只能出现在`/**`和`*/`之间，使用javadoc的方式主要有2种：**嵌套HTML**或者**使用"文档标签"**。*独立文档标签*是一种以"@"开头的命令，需要放到注释行的最前面；*内联文档标签*可以出现在javadoc注释中的任何地方，也是以"@"开头，但要包含在花括号内。

根据文档注释位置后面的元素区分，共有3种文档注释类型：类，属性和方法。也就是说，类注释位于类类定义之前，属性注释位于属性定义之前，方法注释位于方法定义之前。

```java
//:object/Documentation1.java
/**类注释*/
public class Documentation1 {
  /**属性注释*/
  public int i;
  
  /**方法注释*/
  public void f() {}
}///:~
```

> 注意：Javadoc只能为**public**和**protected**成员进行注释，**private**和包访问成员会忽略掉，看不到输出结果(当然，也可以使用**-private**标识来引入**private**成员)，这是因为只有**public**和**protected**成员可对外访问。

### 嵌入式HTML

Javadoc能够将HTML命令传递给生成的HTML文档，这能够让你充分利用HTML。嵌入HTML代码的主要目的是格式化代码，但也可以用于规范普通文本，如：

```java
//: object/Documentation2.java
//格式化代码
public class Documentation2 {
  /**
  * <pre>
  *	System.out.println(new Date);
  * </pre>
  */
}///:~

//: object/Documentation3.java
//格式化普通文本
public class Documentation3 {
  /**
  * 也可以使用<em></em>插入列表格式
  * <ol>
  *		<li>item1</li>
  *		<li>item2</li>
  *		<li>item3</li>
  * </ol>
  */
}///:~
```

Javadoc会抛弃文档注释中每行开头的*和前置空格，并对所有内容重新格式化以便符合标准文档外观，不要使用`<h1>`或者`<hr>`之类的标题标签，因为javadoc会插入自己的标题，可能会产生干扰。

### 标签示例

#### @see

该标签允许用户引用其他文档，javadoc会根据@see标签生成链接到其他文档的HTML超链接。Javadoc不会检查你提供的超链接是否有效，使用格式如下：

```java
/**
* @see classname
* @see fully-qualified-classname
* @see fully-qualified-classname#method-name
*/
```

#### {@link package.class#member label}

与@see类似，但是它用于行内，使用*label*而不是"See Also"作为超链接文本。

#### {@docRoot}

产生到文档根目录的相对地址，用于文档树页面的显式超链接。

#### {@inheritDoc}

继承从当前类最直接的基类相关文档到当前文档注释中。

#### @version

可以是任何你认为适合在版本中说明的重要信息。当javadoc命令行中使用**-version**标识时，会在生成的HTML文档中特别提取出版本信息。

```java
/**
* @version version-infomation
*/
```

#### @author

一般用于展示用户名字，当然也可以包括电子邮件或者其他任何合适的个人信息。当javadoc命令行中使用**-author**标识时，生成的HTML文档会特别提取出作者信息。可以使用多个@author标签来列出所有作者，但是必须连续放置，所有的作者信息在生成的HTML文档中会合并成一个段落。

```java
/**
* @author author-infomation
*/
```

#### @since

该标签允许开发者指定程序中特定功能代码开始添加进来使用的版本号。在Java的HTML文档中可以查看某个类或者方法在JDK中的引用版本。

#### @param

```java
/**
* @param parameter-name description
*/
```

该标签在方法文档注释中很有用，其中*parameter-name*表示参数列表中的参数名，*description*是可延续多行的文本，在新的文档标签开始时结束。每个参数都需要一个@param标签。

#### @return

该标签在方法文档注释中使用，用于描述返回值的含义，可以延续多行。

```java
/**
* @return description
*/
```

#### @throws

描述方法调用失败时抛出的对象，在调用某些方法时可能产生多种不同类型的异常，所有的这些异常信息都需要描述。

```java
/**
* @throws fully-qualified-class-name description
*/
```

#### @deprecated

用于描述某些过时的类、方法或者属性，该标签建议用户不要再使用这些特定，因为在将来很可能被移除。使用**@deprecated**标记的方法，编译器会产生警告提示。在Java SE5中**@deprecated**标签已经被**@Deprecated**注解替代。

## 编码风格

- 类的首字母大写，采用驼峰式命名格式，即所有的单词并在一起并且每个单词的首字母都大写。
- 方法、属性命名首字母小写，采用驼峰式命名格式。
- 命名一定要有意义，除非是公众认同的单词，否则尽量不要采取缩写方式。

```java
class AllTheColorsOfTheRainbow{
  int anIntegerRepresentingColors;
  
  void changeTheHueOfTheColor(int newHue) {
    //...
  }
  //...
}
```